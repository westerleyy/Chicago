---
title: "Ride-sharing in Chicago"
author: "Wesley Chioh"
date: "June 3, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(scipen = 999)
options(digits = 7)
#Loading libraries

library(tidyverse)
library(viridis)
library(lubridate)
library(tmap)
library(tmaptools)
library(sf)
library(spdep)
library(spatstat)
library(rgdal)
library(viridis)
library(RColorBrewer)
library(plotly)
library(gridExtra)
#library(rspatial)
library(plotly)

#UserInput
CensusTracts <- "tl_2018_17_tract.shp"
ChicagoCensusTracts <- "ChicagoBoundaries.shp"
Rideshare_Chicago <- "ChicagoRideshareNovember2018.rds"
CountyFP <- as.character("031")
ReducedCalendarDays <- 1:7
k <- 4

#Reading data
Rideshare_Chicago <- read_rds(Rideshare_Chicago)
IL_CookCounty_CensusTracts <- read_shape(CensusTracts,
                              stringsAsFactors = F) %>%
  filter(COUNTYFP == CountyFP)
IL_CookCounty_CensusTracts <- IL_CookCounty_CensusTracts[!(IL_CookCounty_CensusTracts$TRACTCE == "990000"),]
ChicagoCensusTracts <- read_shape(ChicagoCensusTracts,
                                  stringsAsFactors = F)

#Shrinking data
ReducedRideshareChicago <- Rideshare_Chicago %>%
  mutate(Days = day(Trip.Start.Date),
         Trip.Seconds = str_replace_all(Trip.Seconds, ",", "") %>%
           as.numeric(),
         Trip.Minutes = round(Trip.Seconds/60,0),
         DaysofWeek = weekdays(Trip.Start.Date),
         isWeekend = "Weekday") %>%
  filter(Days %in% ReducedCalendarDays)
colnames(ReducedRideshareChicago)[1]<-"Trip.ID"
isWeekend <- function (df) {
  for (row in 1:nrow(df)){
    if (df[row,"DaysofWeek"] %in% c("Saturday","Sunday")){
      df[row,"isWeekend"] <- "Weekend"
    }
  }
  return(df)
}
ReducedRideshareChicago <- isWeekend(ReducedRideshareChicago)
```  

## Ride-sharing in Chicago

In this markdown, I will look at ride-sharing data provided by the city of Chicago, IL for the first week of November 2018. The entire data set up till May 2019 is approximately 6.5GB. In the interest of time and limited processing power, I decided to just look at the a small segment of the entire dataset, which in itself is not insignificant.  

Chicago (brown) is located in Cook County, IL as shown in the map below.   

```{r Map of Chicago, echo=FALSE}
IllinoisCookCountyMap <- tm_shape(IL_CookCounty_CensusTracts) + 
  tm_polygons(col = "#f2f2f2")
ChicagoMap <- tm_shape(ChicagoCensusTracts) + 
  tm_polygons(col = "#e5d8bd", lcol = "white")
IllinoisCookCountyMap + 
  ChicagoMap + 
  tm_layout(main.title = "Map of Chicago in Cook County, IL",
            main.title.size = 1)
```

The data provided by ride-sharing companies to the City of Chicago were anonymized such that the drop-off and pick-up locations correspond to US Census Bureau TIGER Census Tracts, times were rounded to the nearest 15 minute-interval, and fares and tips were rounded to the nearest $2.50 and $1.00 respectively . This was to protect the identity of riders. In about a third of all rides in November 2018, the identity of the rider(s) could still be determined after rounding times to the nearest 15 minute-interval and locations to the Census Tract. In these cases, the Census Tracts fields were left blank. These observations were eliminated from the following analysis. 

```{r Scatterplot of Rides , echo = FALSE, fig.width = 7, fig.height = 7}
SharedTrip.Labs <- c(false = "Unshared", true = "Shared")
RidesScatter <- ggplot(ReducedRideshareChicago, aes(x = Trip.Miles, y = Fare)) + 
  geom_point(alpha = 0.4, stroke = 0, aes(color = Trip.Minutes)) +
  labs(x = "Distance (mi)", y = "Fare ($)", title = "The Fare Game", fill = "Duration (min)") + 
  scale_color_viridis_c("Duration (min)") + 
  facet_grid(isWeekend~Shared.Trip.Authorized, 
             #nrow = 1,
             labeller = labeller(Shared.Trip.Authorized = SharedTrip.Labs))
RidesScatter
```

```{r Shared Rides, echo = FALSE}
SharedRides <- ReducedRideshareChicago %>%
  filter(Shared.Trip.Authorized == "true")
UnsharedRides <- ReducedRideshareChicago %>%
  filter(Shared.Trip.Authorized == "false")
```


The rideshare data appears to show some degree of heteroskedasticity when distance is plotted against fare for unshared rides. interestingly, rides taken on weekends do not appear to be any more expensive than those on weekdays. The distributions are roughly identical. If anything, it appears that unshared rides on weekdays are most likely to be the most expensive out of the four types of rides compared above.  

More importantly, I am interested in the geographical distribution of riders in Chicago. Since unshared rides account for `r paste(round(nrow(UnsharedRides)/nrow(ReducedRideshareChicago)*100,2), "%", sep = "")` of rides in Chicago, and pooled rides appear to display very different fare chracteristics from non-pooled rides, I will only considered unshared rides in the following analyses.  

Grouping each trip by its pickup and dropoff census tract, a histogram for the frequency in which tract a passenger is picked up and dropped off from can be found. Both histograms demonstrate a significant right-skew with an extremely long tail. That is to say, most tracts experienced 50 or less pick-ups and drop-offs in the first week of November 2018.  

```{r pick up histogram}
PickupCount <- ReducedRideshareChicago %>%
  group_by(Pickup.Census.Tract) %>%
  summarize(Pickup = n_distinct(Trip.ID))
DropoffCount <- ReducedRideshareChicago %>%
  group_by(Dropoff.Census.Tract) %>%
  summarize(Dropoff = n_distinct(Trip.ID))
TractCounts <- full_join(PickupCount, DropoffCount, by = c("Pickup.Census.Tract" = "Dropoff.Census.Tract")) %>%
  transform(Pickup.Census.Tract = as.factor(Pickup.Census.Tract))
TractCounts[is.na(TractCounts)] <- 0
colnames(TractCounts)[1] <- "Census Tracts"
PickUpHist <- ggplot(TractCounts, aes(x = Pickup)) + 
  geom_histogram(binwidth = 50) + 
  labs(x = "Number of Pickups", y = "Number of Census Tracts")
DropoffHist <- ggplot(TractCounts, aes(x = Dropoff)) + 
  geom_histogram(binwidth = 50) + 
  labs(x = "Number of Dropoffs", y = "Number of Census Tracts") 
grid.arrange(PickUpHist, DropoffHist, ncol = 2, nrow = 1, top = "Histograms of Pickups and Dropoffs by Census Tracts")
```
   

Cartographically, this implies the following: 
```{r Thematic Mapping, message=FALSE, warning=FALSE}
TractCounts$geoid10 <- as.character(TractCounts$`Census Tracts`)
Ridercounts <- left_join(ChicagoCensusTracts, TractCounts, by = "geoid10")
Ridercounts[is.na(Ridercounts)] <- 0
tm_shape(Ridercounts) + 
  tm_polygons("Pickup")
tm_shape(Ridercounts) + 
  tm_polygons("Dropoff")
```
```{r fivenum}
fivenum(Ridercounts$Pickup)
fivenum(Ridercounts$Dropoff)
```

```{r Rider Counts, echo = FALSE}
RidercountsSorted <- Ridercounts %>%
  filter(Pickup > 47,
         Dropoff > 48) %>%
  summarize(TotalPickups = sum(Pickup),
            TotalDropoffs = sum(Dropoff))
```

Based on the `fivenum` summaries above, we can see that 75% of all census tracts had less than 50 pick-ups and drop-offs in the first 7 days of November 2018. in fact, `r paste(round(RidercountsSorted$TotalPickups/82680*100), "%", sep = "")` and `r paste(round(RidercountsSorted$TotalDropoffs/82680*100), "%", sep = "")` occur within the a quarter of all census tracts in Chicago. 



In the following chunk, I have created a first-order row standardized queen contiguity spatial weights matrix for census tracts in Chicago. The census tracts file used to generate this matrix includes pick-up and drop-off numbers shown in the histogram above. 
```{r Queen Contiguity}
ChicagoWeights <- poly2nb(Ridercounts, row.names = Ridercounts$geoid10, queen = T)
ChicagoWeightsM <- nb2mat(ChicagoWeights)
ChicagoWeightsWW <- nb2listw(ChicagoWeights, style = "B")
ChicagoWeightsRSM <- nb2listw(ChicagoWeights)
ChicagoRWM <- mat2listw(ChicagoWeightsM, style='W')
```

The Global Moran's I plot for pick-ups below shows that values are primarily clustered in the first quadrant. This suggests that census tracts with a high number of pickups are more likely to be contiguous to other census tracts with a high number of pick-ups as well. In other words, the number of pick-ups in a census tract is spatially autocorrelated. In the Moran's I value is `r  moran(Ridercounts$Pickup, ChicagoWeightsWW, n = length(ChicagoWeightsWW$neighbours), S0 = Szero(ChicagoWeightsWW))[1]` which is consistent with strong spatial autocorrelation. Running a Monte Carlo simulation with 499 permutations with a p-value of 0.02, the result from the Moran's I test is statistically significant.  

```{r Global Queen Pickup}
moran.plot(Ridercounts$Pickup, ChicagoRWM)
MonteCarloPickUpQueen <- moran.mc(Ridercounts$Pickup, ChicagoWeightsWW, nsim = 499)
MonteCarloPickUpQueen
plot(MonteCarloPickUpQueen, main = "", las=1)
```

```{r Local Queen Pickup, echo=FALSE, eval=FALSE}
Ridercounts2<-Ridercounts
LMoran.Queen.Pickup <- localmoran(Ridercounts$Pickup, ChicagoWeightsRSM)
summary(LMoran.Queen.Pickup)
Ridercounts2$s_Pickup <- scale(Ridercounts2$Pickup) %>%
  as.vector()
Ridercounts2$lag_s_Pickup <- lag.listw(ChicagoWeightsRSM, Ridercounts2$s_Pickup)
Ridercounts2$quad_sig_q_pickup <- NA
Ridercounts2[(Ridercounts2$s_Pickup >= 0 &
              Ridercounts2$lag_s_Pickup >= 0) &
              (LMoran.Queen.Pickup[,5] <= 0.05), 
            "quad_sig_q_pickup"] <- "High-High"
Ridercounts2[(Ridercounts2$s_Pickup <= 0 &
              Ridercounts2$lag_s_Pickup <= 0) &
              (LMoran.Queen.Pickup[,5] <= 0.05), 
            "quad_sig_q_pickup"] <- "Low-Low"
Ridercounts2[(Ridercounts2$s_Pickup >= 0 &
              Ridercounts2$lag_s_Pickup <= 0) &
              (LMoran.Queen.Pickup[,5] <= 0.05), 
            "quad_sig_q_pickup"] <- "High-Low"
Ridercounts2[(Ridercounts2$s_Pickup <= 0 &
              Ridercounts2$lag_s_Pickup >= 0) &
              (LMoran.Queen.Pickup[,5] <= 0.05), 
            "quad_sig_q_pickup"] <- "Low-High"
Ridercounts2[(LMoran.Queen.Pickup[,5] > 0.05), 
            "quad_sig_q_pickup"] <- "Not Signif"
Ridercounts2$quad_sig_q_pickup <- Ridercounts2$quad_sig_q_pickup %>%
  as.factor()

tm_shape(Ridercounts2) + 
  tm_polygons("quad_sig_q_pickup")
```

Pivoting to the Local Indicator of Spatial Association (LISA) for pickups in Chicago using Geoda, the following significance map can be derived.
```{r LISA Queen Pickups, echo = FALSE, fig.cap="Significance Map of Dropoffs", fig.height= 6, fig.width=6, out.width="70%"}
knitr::include_graphics("LISA/LISA_Queen_Pickup.png")
```

Repeating the same for drop-offs, the Moran's I value is `r  moran(Ridercounts$Dropoff, ChicagoWeightsWW, n = length(ChicagoWeightsWW$neighbours), S0 = Szero(ChicagoWeightsWW))[1]` which is consistent with strong spatial autocorrelation and the resuls from the pickups.

```{r Queen Dropoff}
moran.plot(Ridercounts$Dropoff, ChicagoRWM)
MonteCarloDropoffQueen <- moran.mc(Ridercounts$Dropoff, ChicagoWeightsWW, nsim = 499)
MonteCarloDropoffQueen
plot(MonteCarloDropoffQueen, main = "", las=1)
```

Pivoting to the Local Indicator of Spatial Association (LISA) for dropoffs in Chicago using Geoda, the following significance map can be derived. 
```{r LISA Queen Dropoffs, echo = FALSE, fig.cap="Significance Map of Dropoffs", fig.height= 6, fig.width=6, out.width="70%"}
knitr::include_graphics("LISA/LISA_Queen_Dropoff.png")
```

```{r Local Queen Dropoff, echo=FALSE, eval=FALSE}
Ridercounts2<-Ridercounts
LMoran.Queen.Dropoff <- localmoran(Ridercounts$Dropoff, ChicagoWeightsRSM)
summary(LMoran.Queen.Dropoff)
Ridercounts2$s_Dropoff <- scale(Ridercounts2$Dropoff) %>%
  as.vector()
Ridercounts2$lag_s_Dropoff <- lag.listw(ChicagoWeightsRSM, Ridercounts2$s_Dropoff)
Ridercounts2$quad_sig_q_Dropoff <- NA
Ridercounts2[(Ridercounts2$s_Dropoff >= 0 &
              Ridercounts2$lag_s_Dropoff >= 0) &
              (LMoran.Queen.Dropoff[,5] <= 0.05), 
            "quad_sig_q_Dropoff"] <- "High-High"
Ridercounts2[(Ridercounts2$s_Dropoff <= 0 &
              Ridercounts2$lag_s_Dropoff <= 0) &
              (LMoran.Queen.Dropoff[,5] <= 0.05), 
            "quad_sig_q_Dropoff"] <- "Low-Low"
Ridercounts2[(Ridercounts2$s_Dropoff >= 0 &
              Ridercounts2$lag_s_Dropoff <= 0) &
              (LMoran.Queen.Dropoff[,5] <= 0.05), 
            "quad_sig_q_Dropoff"] <- "High-Low"
Ridercounts2[(Ridercounts2$s_Dropoff <= 0 &
              Ridercounts2$lag_s_Dropoff >= 0) &
              (LMoran.Queen.Dropoff[,5] <= 0.05), 
            "quad_sig_q_Dropoff"] <- "Low-High"
Ridercounts2[(LMoran.Queen.Dropoff[,5] > 0.05), 
            "quad_sig_q_Dropoff"] <- "Not Signif"
Ridercounts2$quad_sig_q_Dropoff <- Ridercounts2$quad_sig_q_Dropoff %>%
  as.factor()

tm_shape(Ridercounts2) + 
  tm_polygons("quad_sig_q_Dropoff")
```

```{r Spatial Polygons Conversion, echo = FALSE, warning=FALSE, message=FALSE, eval = F}
RiderCountsSpatialPolygons <- as(Ridercounts, "Spatial")
writeOGR(obj=RiderCountsSpatialPolygons, dsn="./RiderCounts", layer="Chicago Rideshare", driver="ESRI Shapefile", overwrite_layer = T)
```

Thus far,the analyses have been focused on using a spatial Queen contiguity spatial weights matrix. Initially, Queen contiguity was selected as it is the more permissive of the two contiguity methods. This takes into account the effect of contiguity from all possible directions. However, census tracts come in different shapes and sizes. This assumes that distance and size of the census tract has less of an impact on autocorrelation.  

Tobler's first law of geography states that closer things are more related than farther things. Instead of using contiguity, which takes in census tracts of various sizes, the degree of spatial autocorrelation might be more accurately measured by creating a spatial weights matrix on the basis of k-nearest neighbors where k = 4. k = 4 is an arbitrary selection. Given that the modal number of  queen-contiguous neighbors is between 7 and 8, the k-value should be less than that so as to not repeat the analyses above. 

Below is a connectivity map for census tracts in Chicago where k = 4. 

```{r knn}
#Long and Lat of Centroid of Census Tract
Ridercounts3 <- inner_join(Ridercounts, as.data.frame(IL_CookCounty_CensusTracts), by = c("geoid10" = "GEOID"))
#LongLat required for KNN analysis
ChicagoCensusTractsLongLat <- cbind(as.numeric(Ridercounts3$INTPTLON), as.numeric(Ridercounts3$INTPTLAT)) %>%
  as.matrix()
#Calculating KNN and returning nb object
ChicagoWeightsKNN <- knearneigh(ChicagoCensusTractsLongLat, k, longlat = T)
ChicagoKNN <- knn2nb(ChicagoWeightsKNN)
#Plotting connectivity map
#tmap does not support nb object
Ridercounts4<-Ridercounts[,4]
plot(Ridercounts4, col= "#f7f7f7",reset = F, main = "Connectivity Map (k = 4)")
plot(ChicagoKNN,ChicagoCensusTractsLongLat, add = T, col = "#fbb4ae", cex = 0.5)
#Converting to matrices
ChicagoKNNM <- nb2mat(ChicagoKNN)
ChicagoKNNWW <- nb2listw(ChicagoKNN, style = "B")
ChicagoKNNRSM <- nb2listw(ChicagoKNN)
ChicagoKNNRWM <- mat2listw(ChicagoKNNM, style='W')
```


```{r knn Pickup}
moran.plot(Ridercounts$Pickup, ChicagoKNNRWM)
MonteCarloPickUpKNN <- moran.mc(Ridercounts$Pickup, ChicagoKNNWW, nsim = 499)
MonteCarloPickUpKNN
plot(MonteCarloPickUpKNN, main = "", las=1)
```

```{r Local knn Pickup, echo=FALSE, eval=FALSE}
Ridercounts4<-Ridercounts
LMoran.knn.Pickup <- localmoran(Ridercounts4$Pickup, ChicagoKNNRSM)
summary(LMoran.knn.Pickup)
Ridercounts4$s_Pickup <- scale(Ridercounts4$Pickup) %>%
  as.vector()
Ridercounts4$lag_s_Pickup <- lag.listw(ChicagoKNNRSM, Ridercounts4$s_Pickup)
Ridercounts4$quad_sig_k_pickup <- NA
Ridercounts4[(Ridercounts4$s_Pickup >= 0 &
              Ridercounts4$lag_s_Pickup >= 0) &
              (LMoran.knn.Pickup[,5] <= 0.05), 
            "quad_sig_k_pickup"] <- "High-High"
Ridercounts4[(Ridercounts4$s_Pickup <= 0 &
              Ridercounts4$lag_s_Pickup <= 0) &
              (LMoran.knn.Pickup[,5] <= 0.05), 
            "quad_sig_k_pickup"] <- "Low-Low"
Ridercounts4[(Ridercounts4$s_Pickup >= 0 &
              Ridercounts4$lag_s_Pickup <= 0) &
              (LMoran.knn.Pickup[,5] <= 0.05), 
            "quad_sig_k_pickup"] <- "High-Low"
Ridercounts4[(Ridercounts4$s_Pickup <= 0 &
              Ridercounts4$lag_s_Pickup >= 0) &
              (LMoran.knn.Pickup[,5] <= 0.05), 
            "quad_sig_k_pickup"] <- "Low-High"
Ridercounts4[(LMoran.knn.Pickup[,5] > 0.05), 
            "quad_sig_k_pickup"] <- "Not Signif"
Ridercounts4$quad_sig_k_pickup <- Ridercounts4$quad_sig_k_pickup %>%
  as.factor()

tm_shape(Ridercounts4) + 
  tm_polygons("quad_sig_k_pickup")
```


```{r knn dropoff}
moran.plot(Ridercounts$Dropoff, ChicagoKNNRWM)
MonteCarloDropoffKNN <- moran.mc(Ridercounts$Dropoff, ChicagoKNNWW, nsim = 499)
MonteCarloDropoffKNN
plot(MonteCarloDropoffKNN, main = "", las=1)
```

At the same time, I wanted to see where and when were the busiest rides. 

```{r, eval=FALSE}
PeakRequestTime <- ReducedRideshareChicago %>% 
  group_by(isWeekend, Trip.Start.Time, Shared.Trip.Authorized) %>%
  summarize(Trips = n_distinct(Trip.ID)) %>%
  transform(Trip.Start.Time = strptime(Trip.Start.Time, format = "%H:%M:%S"))
PeakRequestTimePlot <- ggplot(PeakRequestTime, aes(x = Trip.Start.Time, y = Trips)) + 
  geom_line(aes(color = isWeekend))
PeakRequestTimePlot
  
```

